'''
DTMF Decoder

Usage:
	python decode_phone.py [filename] [-o] [-a]

Locate and decode DTMF sequences in the WAV file [filename]

-o:		Plot output with matplotlib.
-a:		In addition to plotting output, plot each frequency peak and detected
		range.
'''

import numpy as np
from scipy import signal
from scipy.io import wavfile
from scipy.ndimage.filters import maximum_filter
import matplotlib.pyplot as plt

DTMF_FREQS = [697, 770, 852, 941, 1209, 1336, 1477, 1633]
DTMF_DATA = [
	  ['1', '2', '3', 'A']
	, ['4', '5', '6', 'B']
	, ['7', '8', '9', 'C']
	, ['*', '0', '#', 'D']
]

def _decode_detected_peaks(peaks, skip):
	'''
	Helper function for decode_dtmf. Does the actual decoding work.

	@param peaks: Peak ranges/maxfilter pairs, from findfreq
	@param skips: Array of frequency indices to skip over

	@return: Pairs of a DTMF symbol and range of sample numbers it occurs at
	'''
	ret = []

	for i in range(4):
		if i in skip:
			continue
		for j in range(4):
			if j+4 in skip:
				continue
			low_freq = peaks[i][0]
			high_freq = peaks[j+4][0]

			#iterate over all peaks of high/low pairs
			for low_min, low_max in low_freq:
				for high_min, high_max in high_freq:
					overlap = range(max(low_min, high_min)
						, min(high_max, low_max)+1)
					if overlap:
						ret.append((DTMF_DATA[i][j], overlap))

	return ret

def decode_detected_peaks(peaks, ignore_nat=1):
	'''
	Decode the output of `findfreq` into DTMF data.

	@param peaks: list of (list of ranges, sequence maximum) pairs generated by
		findfreq
	@param ignore_nat: If a peak's height is this many nats below the largest
		peak's height, the corresponding frequency's is ignored

	@return: Pairs of a DTMF symbol and range of sample numbers it occurs at
	'''
	skip = []
	largest_filter = max(i[1].max() for i in peaks)

	for i, (_, maximum) in enumerate(peaks):
		#if the peaks weren't high enough compared to other filters, ignore detected peaks
		if np.log(largest_filter/maximum.max()) > ignore_nat:
			skip.append(i)
			continue

	symbol_ranges = _decode_detected_peaks(peaks, skip)

	return symbol_ranges


def get_peak_ranges(sig, minheight, minlength):
	'''
	Using the signal supplied, finds ranges of samples where peaks occur

	@param sig:	A signal, preferably the output of a maximum_filter
	@param minheight: When sig has a value more than this fraction of its
		maximum, the signal has peaked
	@param minlength: The minimum length a range must be to include in the
		return value.

	@return: List of ranges of sample numbers peaks occur at
	'''
	# adopted match filter from
	# https://dsp.stackexchange.com/questions/20231/good-way-to-detect-pulse-with-known-width-with-background-noise

	# select peaks where we have enough elevation
	peak_mask = sig > sig.max() / minheight
	# rising edges at 1, falling at -1
	correlate = np.correlate(peak_mask, [-1, 1], mode='same')

	rising = np.where(correlate == 1)[0]
	falling = np.where(correlate == -1)[0]
	# magic that finds significant bands compared to the sequence length
	ranges = [(rising[i], falling[i]) for i in range(len(rising))
		if (falling[i] - rising[i]) >= minlength]

	return ranges

def findfreq(sig, frequency, sequence_length=.125, minheight=1.5):
	'''
	Convolve a signal with a sine wave of frequency `frequency` (and length
	sequence_length seconds), then apply a max filter to find when peaks of that
	frequency occur in the signal

	@param sig: A 2-tuple of a sample rate and a signal, like the return value
		of wavfile.read
	@param frequency: The frequency of the signal in Hz
	@param sequence_length: The length of the generated tone in seconds.
		Keep in mind that short sequences have uncertain frequency, but long
		sequences have uncertain time (i.e. peak overlap may occur)
	@param minheight: After the max filter is applied, the maximum of that
		signal divided by this number is the minimum height of a peak. Controls
		how high a peak has to be to actually begin.

	@return: 2-tuple of sample numbers where peaks start and the signal/sine
		convolution under the max filter
	'''
	fwindow = sequence_length * sig[0]
	#create a sine wave of the given frequency with the given length
	full_wavelength = np.linspace(0, 2 * np.pi * sequence_length, int(fwindow))
	sinusoid = np.sin(frequency * full_wavelength)

	response = np.absolute(signal.convolve(sig[1], sinusoid))
	max_data = maximum_filter(response, fwindow/4)
	ranges = get_peak_ranges(max_data, minheight, .75 * fwindow)

	return ranges, max_data

def decode_dtmf(sig, plot_out=False, plot_freqs=False):
	'''
	Decode DTMF data in a WAV file

	@param sig: A 2-tuple of a sample rate and a signal, like the return value
		of wavfile.read
	@param plot_out: Whether or not to plot the output of the decoder
	@param plot_freqs: Whether or not to plot each frequency's peaks

	@return: List of decoded characters corresponding to the DTMF sequence
	'''

	if plot_out:
		plt.figure(1)
		plt.subplot(2, 1, 1)
		plt.plot(sig[1], label="Original")
		plt.legend()

	peaks = []

	# find peaks
	for num, frequency in enumerate(DTMF_FREQS):
		ranges, max_data = findfreq(sig, frequency)
		peaks.append((ranges, max_data))

		if plot_freqs:
			plt.figure(2)
			plt.subplot(len(DTMF_FREQS), 1, num + 1)
			plt.plot(max_data, label="Frequency Peaks (%d Hz)" % frequency)
			samples = np.arange(len(max_data))
			ran = np.any([np.isin(samples, range(mi, ma)) for mi, ma in ranges], 0)
			plt.plot(ran * max_data.max(), label="Tone Detected")
			plt.legend()

	# decode peaks
	symbol_ranges = decode_detected_peaks(peaks)

	if plot_out:
		plt.figure(1)
		plt.subplot(2, 1, 2)
		# plot each frequency convolution
		for num, i in enumerate(peaks):
			plt.plot(i[1], label="%d Hz"%DTMF_FREQS[num])
		# show each symbol decoded
		y_pos = max(i[1].max() for i in peaks) / 2
		for i in symbol_ranges:
			x_pos = (i[1][0] + i[1][1]) / 2
			plt.text(x_pos, y_pos, i[0], fontdict={'size': 16})
		plt.legend()

	#sort by snd and drop snd
	ret = map(lambda x: x[0], sorted(symbol_ranges, key=lambda a: a[1][0]))
	return list(ret)

def _main():
	import sys
	if len(sys.argv) < 2:
		print(__doc__)
		return

	filename = sys.argv[1]
	plot_all = False
	plot_out = False
	if "-a" in sys.argv[2:]:
		plot_all = True
		plot_out = True
	if "-o" in sys.argv[2:]:
		plot_out = True
	print("Reading file %s..." % filename)

	in_sample, in_data = wavfile.read(filename)
	#downgrade to mono
	mono_data = in_sample, in_data.sum(axis=1) / 2

	ret = decode_dtmf(mono_data, plot_freqs=plot_all, plot_out=plot_out)
	if plot_all or plot_out:
		plt.show()
	else:
		print(' '.join(ret))

if __name__ == "__main__":
	_main()
