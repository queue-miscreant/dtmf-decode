'''
DTMF Decoder

Usage:
	python decode_phone.py sample.wav

Locate and decode DTMF sequences in the WAV file `sample`
'''

import numpy as np
from scipy import signal
from scipy.io import wavfile
from scipy.ndimage.filters import maximum_filter

DTMF_FREQS = [697, 770, 852, 941, 1209, 1336, 1477, 1633]
DTMF_DATA =	[
	  ['1', '2', '3', 'A']
	, ['4', '5', '6', 'B']
	, ['7', '8', '9', 'C']
	, ['*', '0', '#', 'D']
]

def decode_dtmf(peaks, ignore_nat=1, coincid_nat=.02):
	'''
	Decode the output of `findfreq` into DTMF data.

	@param peaks: (sample number, sequence maximum) pairs generated by findfreq
	@param ignore_nat: If the largest maximum divided by any particular maximum
		exceeds this value in nats, the peaks are discarded
	@param coincid_nat: If a peak is within this number of nats of another,
		then they may be considered the same peak

	@return: decoded DTMF sequence, ordered by sample number in peaks
	'''
	skip = []

	ret = []
	largest_filter = max(i[1] for i in peaks)

	for i, (_, maximum) in enumerate(peaks):
		#if the peaks weren't high enough compared to other filters, no peaks
		if np.log(largest_filter/maximum) > ignore_nat:
			skip.append(i)
			continue

	for i in range(4):
		if i in skip:
			continue
		for j in range(4):
			if j+4 in skip:
				continue
			low_freq = peaks[i][0]
			high_freq = peaks[j+4][0]

			#iterate over all peaks of high/low pairs
			for low_peak in low_freq:
				for high_peak in high_freq:
					#magic for the logarithmic distance a low_freq peak can be
					#considered the same as a high_freq peak
					if abs(np.log(high_peak) - np.log(low_peak)) < coincid_nat:
						ret.append((DTMF_DATA[i][j], high_peak))

	#sort by snd and drop snd
	ret = map(lambda a: a[0], sorted(ret, key=lambda a: a[1]))

	return list(ret)

def findfreq(sig, frequency, sample_rate, sequence_length=.125, minheight=1.5):
	'''
	Convolve a signal with a frequency (of length sequence_length), then
	apply a max filter to find when peaks of that frequency occur in the signal

	@param sig: A numpy array or object that works with signal.convolve
	@param frequency: The frequency of the signal in Hz
	@param sample_rate: The sample rate of `sig`
	@param sequence_length: The length of the generated tone in seconds.
		Keep in mind that short sequences have uncertain frequency, but long
		sequences have uncertain time (i.e. peak overlap may occur)
	@param maxwidth: After the max filter is applied, the maximum of that signal
		divided by this number is the minimum height of a peak. Controls how
		high a peak has to be to actually begin.

	@return: 2-tuple of sample numbers where peaks start and the maximum value
		of the signal/frequency convolution under the max filter
	'''
	fwindow = sequence_length * sample_rate
	#create a sine wave of the given frequency with the given length
	full_wavelength = np.linspace(0, 2 * np.pi * sequence_length, int(fwindow))
	sinusoid = np.sin(frequency * full_wavelength)

	response = np.absolute(signal.convolve(sig, sinusoid))
	max_data = maximum_filter(response, fwindow)

	# adopted match filter from
	# https://dsp.stackexchange.com/questions/20231/good-way-to-detect-pulse-with-known-width-with-background-noise

	# select peaks where we have enough elevation
	peak_mask = max_data > max_data.max() / minheight
	# a trick to convert True to 1, False to -1
	peak_mask = peak_mask * 2 - 1
	# select rising edges
	peak_mask = np.correlate(peak_mask, [-1, 1], mode='same') == 2

	peaks = np.where(peak_mask)[0]

	return peaks, max_data.max()

def decode_file(filename):
	'''
	Decode DTMF data in a WAV file

	@param filename: The WAV file to decode
	'''
	in_sample, in_data = wavfile.read(filename)

	#downgrade to mono
	mono_data = in_data.sum(axis=1) / 2

	peaks = []
	for i in DTMF_FREQS:
		peaks.append(findfreq(mono_data, i, in_sample))

	return decode_dtmf(peaks)

def main():
	import sys
	if len(sys.argv) < 2:
		print(__doc__)
		return

	print(decode_file(sys.argv[1]))

if __name__ == "__main__":
	main()
