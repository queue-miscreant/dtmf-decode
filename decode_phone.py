#!/usr/bin/env python3
'''
DTMF Decoder

Usage:
	python decode_phone.py [filename] [-o] [-a]

Locate and decode DTMF sequences in the WAV file [filename]

-o:		Plot output with matplotlib.
-a:		In addition to plotting output, plot each frequency peak and detected
		range.
'''

import numpy as np
from scipy import signal
from scipy.ndimage.filters import maximum_filter
import matplotlib.pyplot as plt

DTMF_FREQS = [697, 770, 852, 941, 1209, 1336, 1477, 1633]
DTMF_DATA = [
	  ['1', '2', '3', 'A']
	, ['4', '5', '6', 'B']
	, ['7', '8', '9', 'C']
	, ['*', '0', '#', 'D']
]

def decode_detected_peaks(peaks, ignore_nat=2):
	'''
	Decode the output of `detect_frequency_peaks` into DTMF data.

	@param peaks: list of (list of ranges, sequence maximum) pairs generated by
		detect_frequency_peaks
	@param ignore_nat: If a peak's height is this many nats below the largest
		peak's height, the corresponding frequency's is ignored

	@return: Triples of a DTMF symbol, range of sample numbers it occurs at,
		and the power ratio in nats by which the peaks differ
	'''
	ret = []

	for i in range(4):
		low_freq, low_sig = peaks[i]
		#iterate over all peaks of high/low pairs
		for low_begin, low_end in low_freq:
			low_max = low_sig[low_begin:low_end].max()
			for j in range(4):
				high_freq, high_sig = peaks[j+4]
				found = False
				for k, (high_begin, high_end) in enumerate(high_freq):
					high_max = high_sig[high_begin:high_end].max()
					#find overlapping region
					overlap = range(max(low_begin, high_begin)
						, min(high_end, low_end)+1)
					natspower = abs(np.log(high_max/low_max))
					if overlap and natspower < ignore_nat:
						ret.append((DTMF_DATA[i][j], overlap, natspower))
						found = True
						high_freq.pop(k)
						break
				if found:
					break

	return ret

def get_peak_ranges(sig, max_frac, minlength):
	'''
	Using the signal supplied, finds ranges of samples where peaks occur

	@param sig:	A signal, preferably the output of a maximum_filter
	@param max_frac: When sig has a value more than this fraction of its
		maximum, the signal has peaked
	@param minlength: The minimum length a range must be to include in the
		return value.

	@return: List of ranges of sample numbers peaks occur at
	'''
	# adopted match filter from
	# https://dsp.stackexchange.com/questions/20231/good-way-to-detect-pulse-with-known-width-with-background-noise

	# select peaks where we have enough elevation
	peak_mask = sig > sig.max() / max_frac
	# rising edges at 1, falling at -1
	correlate = np.correlate(peak_mask, [-1, 1], mode='same')

	rising = np.where(correlate == 1)[0]
	falling = np.where(correlate == -1)[0]
	# magic that finds significant bands compared to the sequence length
	ranges = [(rising[i], falling[i]) for i in range(len(rising))
		if (falling[i] - rising[i]) >= minlength]

	return ranges

def detect_frequency_peaks(sig, frequency, sequence_length=.125, minheight=1.5):
	'''
	Convolve a signal with a sine wave of frequency `frequency` (and length
	sequence_length seconds), then apply a max filter to find when peaks of that
	frequency occur in the signal

	@param sig: A 2-tuple of a sample rate and a signal, like the return value
		of wavfile.read
	@param frequency: The frequency of the signal in Hz
	@param sequence_length: The length of the generated tone in seconds.
		Keep in mind that short sequences have uncertain frequency, but long
		sequences have uncertain time (i.e. peak overlap may occur)
	@param minheight: After the max filter is applied, the maximum of that
		signal divided by this number is the minimum height of a peak. Controls
		how high a peak has to be to actually begin.

	@return: 2-tuple of sample numbers where peaks start and the signal/sine
		convolution under the max filter
	'''
	fwindow = sequence_length * sig[0]
	#create a sine wave of the given frequency with the given length
	full_wavelength = np.linspace(0, 2 * np.pi * sequence_length, int(fwindow))
	sinusoid = np.sin(frequency * full_wavelength)

	response = np.absolute(signal.convolve(sig[1], sinusoid))
	max_data = maximum_filter(response, fwindow/4)
	ranges = get_peak_ranges(max_data, minheight, .75 * fwindow)

	return ranges, max_data

def decode_dtmf(sig, plot_out=False, plot_freqs=False):
	'''
	Decode DTMF data from a signal

	@param sig: A 2-tuple of a sample rate and a signal, like the return value
		of wavfile.read
	@param plot_out: Whether or not to plot the output of the decoder
	@param plot_freqs: Whether or not to plot each frequency's peaks

	@return: List of decoded characters corresponding to the DTMF sequence
	'''
	peaks = []
	# find peaks
	for num, frequency in enumerate(DTMF_FREQS):
		ranges, max_data = detect_frequency_peaks(sig, frequency)
		peaks.append((ranges, max_data))

		if plot_freqs:
			plt.figure(2)
			plt.subplot(len(DTMF_FREQS), 1, num + 1)
			plt.plot(max_data, label="Frequency Peaks (%d Hz)" % frequency)
			samples = np.arange(len(max_data))
			# if a particular sequence number is in a peak
			ran = np.any([np.isin(samples, range(mi, ma)) for mi, ma in ranges], 0)
			plt.plot(ran * max_data.max(), label="Tone Detected")
			plt.legend()

	# decode peaks
	symbol_ranges = decode_detected_peaks(peaks)

	if plot_out:
		plt.figure(1)
		plt.subplot(2, 1, 1)
		plt.plot(sig[1], label="Original")
		plt.legend()

		# plot each frequency convolution
		plt.subplot(2, 1, 2)
		for num, i in enumerate(peaks):
			plt.plot(i[1], label="%d Hz"%DTMF_FREQS[num])
		# show each symbol decoded
		y_pos = max(i[1].max() for i in peaks) / 2
		for i in symbol_ranges:
			x_pos = (i[1][0] + i[1][1]) / 2
			plt.text(x_pos, y_pos, i[0], fontdict={'size': 16})
		plt.legend()

	#sort by snd and drop snd
	ret = map(lambda x: x[0], sorted(symbol_ranges, key=lambda a: a[1][0]))
	return list(ret)

def _main():
	import sys
	from scipy.io import wavfile
	if len(sys.argv) < 2 or "--help" in sys.argv:
		print(__doc__)
		return

	filename = sys.argv[1]
	plot_all = False
	plot_out = False
	if "-a" in sys.argv[2:]:
		plot_all = True
		plot_out = True
	if "-o" in sys.argv[2:]:
		plot_out = True
	print("Reading file %s..." % filename)

	in_sample, in_data = wavfile.read(filename)
	#downgrade to mono
	mono_data = in_sample, in_data.sum(axis=1) / 2

	ret = decode_dtmf(mono_data, plot_freqs=plot_all, plot_out=plot_out)
	if plot_all or plot_out:
		plt.show()
	else:
		print(' '.join(ret))

if __name__ == "__main__":
	_main()
